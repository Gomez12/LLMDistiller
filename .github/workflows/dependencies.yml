name: Dependency Management

on:
  schedule:
    # Run dependency checks daily at 3 AM UTC
    - cron: '0 3 * * *'
  workflow_dispatch:
    inputs:
      update_type:
        description: 'Type of update'
        required: true
        default: 'patch'
        type: choice
        options:
          - patch
          - minor
          - major
      create_pr:
        description: 'Create pull request for updates'
        required: false
        type: boolean
        default: true
  push:
    branches: [ main ]
    paths:
      - 'requirements*.txt'
      - 'pyproject.toml'
      - 'setup.py'

env:
  PYTHON_DEFAULT_VERSION: "3.11"

jobs:
  # Dependency Vulnerability Scan
  vulnerability-scan:
    name: Vulnerability Scan
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v6

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: ${{ env.PYTHON_DEFAULT_VERSION }}

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install safety>=2.3.0 \
                    pip-audit>=2.5.0 \
                    bandit>=1.7.0

    - name: Run Safety vulnerability check
      run: |
        safety check --json --output safety-report.json || true
        safety check --full-report || true

    - name: Run pip-audit vulnerability check
      run: |
        pip-audit --requirement requirements.txt --format=json --output=pip-audit-report.json || true
        pip-audit --requirement requirements.txt || true

    - name: Run pip-audit on dev dependencies
      run: |
        pip-audit --requirement requirements-dev.txt --format=json --output=pip-audit-dev-report.json || true
        pip-audit --requirement requirements-dev.txt || true

    - name: Generate vulnerability report
      run: |
        python -c "
        import json
        from datetime import datetime
        
        print('## Dependency Vulnerability Report')
        print('')
        print(f'**Date:** {datetime.now().isoformat()}')
        print(f'**Scanner:** Safety + pip-audit')
        print('')
        
        # Parse safety report
        try:
            with open('safety-report.json', 'r') as f:
                safety_data = json.load(f)
            
            safety_vulns = safety_data.get('vulnerabilities', [])
            print(f'### Safety Scan Results')
            print('')
            print(f'Found {len(safety_vulns)} vulnerabilities')
            
            if safety_vulns:
                print('| Package | Vulnerability | Severity | Fixed In |')
                print('|---------|---------------|----------|----------|')
                
                for vuln in safety_vulns[:10]:  # Show first 10
                    package = vuln.get('package', 'Unknown')
                    vuln_id = vuln.get('vulnerability_id', 'Unknown')
                    severity = vuln.get('vulnerability_severity', 'Unknown')
                    fixed_in = vuln.get('fixed_versions', ['N/A'])[0]
                    
                    print(f'| {package} | {vuln_id} | {severity} | {fixed_in} |')
                
                if len(safety_vulns) > 10:
                    print(f'| ... | ... | ... | ... |')
                    print(f'| and {len(safety_vulns) - 10} more | | | |')
            else:
                print('âœ… No vulnerabilities found')
            
        except FileNotFoundError:
            print('âš ï¸ Safety report not found')
        except Exception as e:
            print(f'âš ï¸ Error parsing safety report: {e}')
        
        print('')
        
        # Parse pip-audit report
        try:
            with open('pip-audit-report.json', 'r') as f:
                audit_data = json.load(f)
            
            audit_vulns = audit_data.get('vulnerabilities', [])
            print(f'### pip-audit Scan Results')
            print('')
            print(f'Found {len(audit_vulns)} vulnerabilities')
            
            if audit_vulns:
                print('| Package | Vulnerability | Version | Fix |')
                print('|---------|---------------|---------|-----|')
                
                for vuln in audit_vulns[:10]:  # Show first 10
                    package = vuln.get('name', 'Unknown')
                    vuln_id = vuln.get('id', 'Unknown')
                    version = vuln.get('version', 'Unknown')
                    fix_versions = vuln.get('fix_versions', ['N/A'])
                    fix = ', '.join(fix_versions[:2])  # Show first 2 fix versions
                    
                    print(f'| {package} | {vuln_id} | {version} | {fix} |')
                
                if len(audit_vulns) > 10:
                    print(f'| ... | ... | ... | ... |')
                    print(f'| and {len(audit_vulns) - 10} more | | | |')
            else:
                print('âœ… No vulnerabilities found')
                
        except FileNotFoundError:
            print('âš ï¸ pip-audit report not found')
        except Exception as e:
            print(f'âš ï¸ Error parsing pip-audit report: {e}')
        
        print('')
        print('### Recommendations')
        print('')
        print('- Review and update vulnerable dependencies')
        print('- Consider using dependency ranges instead of fixed versions')
        print('- Set up automated dependency updates')
        print('- Monitor security advisories for your dependencies')
        " >> $GITHUB_STEP_SUMMARY

    - name: Upload vulnerability reports
      uses: actions/upload-artifact@v4
      with:
        name: vulnerability-reports
        path: |
          safety-report.json
          pip-audit-report.json
          pip-audit-dev-report.json
        retention-days: 30

  # Dependency Updates
  dependency-update:
    name: Update Dependencies
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' || github.event_name == 'schedule'
    steps:
    - name: Checkout code
      uses: actions/checkout@v6
      with:
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: ${{ env.PYTHON_DEFAULT_VERSION }}

    - name: Install pip-tools
      run: |
        python -m pip install --upgrade pip
        pip install pip-tools>=7.0.0

    - name: Create requirements.in if not exists
      run: |
        if [[ ! -f "requirements.in" ]]; then
          echo "# Core dependencies" > requirements.in
          echo "sqlalchemy>=2.0.0" >> requirements.in
          echo "alembic>=1.12.0" >> requirements.in
          echo "pydantic>=2.0.0" >> requirements.in
          echo "click>=8.1.0" >> requirements.in
          echo "openai>=1.0.0" >> requirements.in
          echo "aiohttp>=3.8.0" >> requirements.in
          echo "asyncio-throttle>=1.0.0" >> requirements.in
          echo "jsonschema>=4.17.0" >> requirements.in
          echo "pandas>=2.0.0" >> requirements.in
          echo "lxml>=4.9.0" >> requirements.in
          echo "python-dotenv>=1.0.0" >> requirements.in
        fi
        
        if [[ ! -f "requirements-dev.in" ]]; then
          echo "# Development dependencies" > requirements-dev.in
          echo "-r requirements.in" >> requirements-dev.in
          echo "pytest>=7.0.0" >> requirements-dev.in
          echo "pytest-asyncio>=0.21.0" >> requirements-dev.in
          echo "pytest-cov>=4.0.0" >> requirements-dev.in


          echo "pre-commit>=3.0.0" >> requirements-dev.in
          echo "types-requests>=2.28.0" >> requirements-dev.in
        fi

    - name: Update dependencies
      run: |
        UPDATE_TYPE="${{ github.event.inputs.update_type || 'patch' }}"
        
        echo "Updating dependencies with strategy: $UPDATE_TYPE"
        
        # Update requirements.in with new versions
        pip-compile --upgrade --resolver=backtracking \
                   --no-header --no-emit-index-url \
                   --build-isolation requirements.in
        
        pip-compile --upgrade --resolver=backtracking \
                   --no-header --no-emit-index-url \
                   --build-isolation requirements-dev.in
        
        echo "Dependencies updated successfully"

    - name: Check for changes
      id: changes
      run: |
        if [[ -n $(git status --porcelain requirements*.txt) ]]; then
          echo "changes=true" >> $GITHUB_OUTPUT
          echo "Found changes in requirements files"
          
          # Show what changed
          echo "### Changes detected:" >> $GITHUB_STEP_SUMMARY
          echo '```diff' >> $GITHUB_STEP_SUMMARY
          git diff requirements*.txt >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
        else
          echo "changes=false" >> $GITHUB_OUTPUT
          echo "No changes in dependencies"
        fi

    - name: Test updated dependencies
      if: steps.changes.outputs.changes == 'true'
      run: |
        # Install updated dependencies
        pip install -r requirements.txt
        pip install -r requirements-dev.txt
        
        # Test basic functionality
        python -c "
        import sqlalchemy
        import pydantic
        import click
        import openai
        import aiohttp
        import pandas
        print('âœ… All core dependencies import successfully')
        "
        
        # Run basic tests
        if [[ -d "tests" ]]; then
          pytest tests/unit/ -v --tb=short || echo "âš ï¸ Some tests failed, but continuing"
        fi

    - name: Create Pull Request
      if: steps.changes.outputs.changes == 'true' && (github.event.inputs.create_pr == 'true' || github.event_name == 'schedule')
      uses: peter-evans/create-pull-request@v5
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        commit-message: "chore: update dependencies"
        title: "ðŸ”„ Automated Dependency Update"
        body: |
          ## Automated Dependency Update
          
          This PR updates project dependencies to their latest versions.
          
          ### Changes
          - Updated requirements.txt with latest compatible versions
          - Updated requirements-dev.txt with latest development tools
          
          ### Testing
          - Basic import tests passed
          - Core functionality verified
          
          ### Next Steps
          - Review the changes
          - Run full test suite
          - Merge if everything looks good
          
          ---
          
          ðŸ¤– This PR was created automatically by the Dependency Management workflow.
        branch: automated-dependency-update
        delete-branch: true
        labels: |
          dependencies
          automated

  # License Compliance Check
  license-check:
    name: License Compliance
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v6

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: ${{ env.PYTHON_DEFAULT_VERSION }}

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install pip-licenses>=4.0.0

    - name: Generate license report
      run: |
        pip install -r requirements.txt
        pip install -r requirements-dev.txt
        
        # Generate license report
        pip-licenses --from=mixed \
                    --format=json \
                    --output-file=licenses.json
        
        pip-licenses --from=mixed \
                    --format=markdown \
                    --output-file=licenses.txt

    - name: Check for problematic licenses
      run: |
        python -c "
        import json
        from pathlib import Path
        
        # Define problematic licenses
        problematic_licenses = {
            'GPL-2.0', 'GPL-3.0', 'AGPL-1.0', 'AGPL-3.0',
            'LGPL-2.0', 'LGPL-2.1', 'LGPL-3.0'
        }
        
        # Allowable licenses (common permissive licenses)
        allowable_licenses = {
            'MIT', 'Apache-2.0', 'BSD', 'BSD-2-Clause', 'BSD-3-Clause',
            'ISC', 'Unlicense', 'Apache Software License'
        }
        
        try:
            with open('licenses.json', 'r') as f:
                licenses_data = json.load(f)
        except FileNotFoundError:
            print('License report not found')
            exit(1)
        
        print('## License Compliance Report')
        print('')
        
        problematic_packages = []
        unknown_licenses = set()
        
        for package_info in licenses_data:
            package_name = package_info.get('name', 'Unknown')
            license_name = package_info.get('license', 'Unknown')
            
            if license_name in problematic_licenses:
                problematic_packages.append({
                    'name': package_name,
                    'license': license_name,
                    'version': package_info.get('version', 'Unknown')
                })
            elif license_name not in allowable_licenses:
                unknown_licenses.add(license_name)
        
        # Report results
        if problematic_packages:
            print('### âš ï¸ Potentially Problematic Licenses')
            print('')
            print('| Package | Version | License |')
            print('|---------|---------|----------|')
            
            for pkg in problematic_packages:
                print(f'| {pkg[\"name\"]} | {pkg[\"version\"]} | {pkg[\"license\"]} |')
            
            print('')
            print('**Note:** These licenses may have copyleft requirements that could affect your project.')
        else:
            print('### âœ… No Problematic Licenses Found')
            print('')
            print('All dependencies use permissive licenses.')
        
        if unknown_licenses:
            print('')
            print('### â„¹ï¸ Unknown Licenses')
            print('')
            print('The following licenses were not classified:')
            print('')
            for license_name in sorted(unknown_licenses):
                print(f'- {license_name}')
        
        print('')
        print('### License Summary')
        print('')
        print(f'- Total packages: {len(licenses_data)}')
        print(f'- Problematic licenses: {len(problematic_packages)}')
        print(f'- Unknown licenses: {len(unknown_licenses)}')
        
        # Exit with error if problematic licenses found
        if problematic_packages:
            print('')
            print('âŒ Action required: Review problematic licenses')
            exit(1)
        else:
            print('')
            print('âœ… License compliance check passed')
        " >> $GITHUB_STEP_SUMMARY

    - name: Upload license report
      uses: actions/upload-artifact@v4
      with:
        name: license-reports
        path: |
          licenses.json
          licenses.txt
        retention-days: 30

  # Dependency Health Score
  health-score:
    name: Dependency Health Score
    runs-on: ubuntu-latest
    needs: [vulnerability-scan, license-check]
    if: always()
    steps:
    - name: Calculate health score
      run: |
        python -c "
        import json
        from pathlib import Path
        from datetime import datetime
        
        print('## Dependency Health Score')
        print('')
        print(f'**Date:** {datetime.now().isoformat()}')
        print('')
        
        # Initialize scores
        vulnerability_score = 100
        license_score = 100
        freshness_score = 100
        
        # Check vulnerability reports
        try:
            with open('vulnerability-reports/safety-report.json', 'r') as f:
                safety_data = json.load(f)
            
            vuln_count = len(safety_data.get('vulnerabilities', []))
            vulnerability_score = max(0, 100 - (vuln_count * 10))
            
            print(f'### Vulnerability Score: {vulnerability_score}/100')
            print(f'- Vulnerabilities found: {vuln_count}')
            
        except FileNotFoundError:
            vulnerability_score = 50
            print(f'### Vulnerability Score: {vulnerability_score}/100')
            print('- Vulnerability scan failed')
        
        # Check license compliance
        try:
            with open('license-reports/licenses.json', 'r') as f:
                licenses_data = json.load(f)
            
            # Simple heuristic: check for common permissive licenses
            good_licenses = {'MIT', 'Apache-2.0', 'BSD', 'ISC'}
            good_count = 0
            
            for pkg in licenses_data:
                if pkg.get('license') in good_licenses:
                    good_count += 1
            
            if licenses_data:
                license_ratio = good_count / len(licenses_data)
                license_score = int(license_ratio * 100)
            
            print(f'### License Score: {license_score}/100')
            print(f'- Packages with permissive licenses: {good_count}/{len(licenses_data)}')
            
        except FileNotFoundError:
            license_score = 50
            print(f'### License Score: {license_score}/100')
            print('- License check failed')
        
        # Calculate overall score
        overall_score = (vulnerability_score + license_score) // 2
        
        print(f'### Overall Health Score: {overall_score}/100')
        print('')
        
        # Provide recommendations
        if overall_score >= 90:
            print('ðŸŸ¢ **Excellent** - Dependencies are in great shape!')
        elif overall_score >= 70:
            print('ðŸŸ¡ **Good** - Dependencies are mostly healthy, some improvements possible')
        elif overall_score >= 50:
            print('ðŸŸ  **Fair** - Some dependency issues need attention')
        else:
            print('ðŸ”´ **Poor** - Significant dependency issues require immediate attention')
        
        print('')
        print('### Recommendations')
        print('')
        
        if vulnerability_score < 80:
            print('- Update vulnerable dependencies')
            print('- Consider automated security updates')
        
        if license_score < 80:
            print('- Review license compatibility')
            print('- Consider alternatives to problematic licenses')
        
        if overall_score >= 80:
            print('- Keep up the good work!')
            print('- Set up regular dependency monitoring')
        
        # Set output for potential use in other workflows
        print(f'score={overall_score}' >> $GITHUB_OUTPUT)
        " >> $GITHUB_STEP_SUMMARY

  # Summary
  summary:
    name: Dependency Management Summary
    runs-on: ubuntu-latest
    needs: [vulnerability-scan, dependency-update, license-check, health-score]
    if: always()
    steps:
    - name: Create summary
      run: |
        echo "## Dependency Management Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        echo "### Job Results" >> $GITHUB_STEP_SUMMARY
        echo "- Vulnerability Scan: ${{ needs.vulnerability-scan.result }}" >> $GITHUB_STEP_SUMMARY
        echo "- Dependency Update: ${{ needs.dependency-update.result }}" >> $GITHUB_STEP_SUMMARY
        echo "- License Check: ${{ needs.license-check.result }}" >> $GITHUB_STEP_SUMMARY
        echo "- Health Score: ${{ needs.health-score.result }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        if [[ "${{ needs.vulnerability-scan.result }}" == "success" ]]; then
          echo "âœ… Vulnerability scan completed successfully" >> $GITHUB_STEP_SUMMARY
        else
          echo "âŒ Vulnerability scan failed" >> $GITHUB_STEP_SUMMARY
        fi
        
        if [[ "${{ needs.dependency-update.result }}" == "success" ]]; then
          echo "âœ… Dependency update process completed" >> $GITHUB_STEP_SUMMARY
        else
          echo "âš ï¸ Dependency update process had issues" >> $GITHUB_STEP_SUMMARY
        fi
        
        if [[ "${{ needs.license-check.result }}" == "success" ]]; then
          echo "âœ… License compliance check passed" >> $GITHUB_STEP_SUMMARY
        else
          echo "âŒ License compliance check failed" >> $GITHUB_STEP_SUMMARY
        fi